using GameTools.API.WorkloadProvider.AiWorkloads;
using GameTools.API.WorkloadProvider.Models;
using GameTools.TownsfolkManager.Contracts;
using GameTools.UserManager.Contracts;
using Microsoft.Extensions.Logging;
using System.Text;
using System.Text.Json;
using System.Xml.Linq;
using ThatDeveloperDad.AIWorkloadManager.Contracts;
using ThatDeveloperDad.Framework.Serialization;
using ThatDeveloperDad.Framework.Wrappers;

namespace GameTools.API.WorkloadProvider
{
    /// <summary>
    /// This manager class allows pass-through reference to the public
    /// DTOs in the Manager classes, and acts to stitch the behaviors
    /// provided by those APIs into activities rpesented to the 
    /// User Interface application.
    /// </summary>
    public class CharacterWorkloads : ICharacterWorkloads
    {
        private readonly ITownsfolkManager _npcManager;
        private readonly IAiWorkloadManager _aiWorker;
        private readonly IUsageMeters _usageManager;
        private readonly ILogger<CharacterWorkloads>? _logger;

        public CharacterWorkloads(ITownsfolkManager npcManager,
                                  IAiWorkloadManager aiWorker,
                                  IUsageMeters usageManager,
                                  ILogger<CharacterWorkloads>? logger)
        {
            _npcManager = npcManager;
            _aiWorker = aiWorker;
            _usageManager = usageManager;
            _logger = logger;

            // Register the DescribeNPC function with the LLM Provider.
            CharGenFunctions.RegisterCharacterGenerationFunctions(_aiWorker);
        }

        /// <summary>
        /// Retrieves a Dictionary of the different options that can 
        /// be used when generating an NPC.
        /// The Dictionary Key identifies the NPC Attribute.
        /// The Value of a Dictionary Entry is the List of Choices.
        /// </summary>
        public Dictionary<string, string[]> GetNpcOptions()
        {
            var options = _npcManager.GetNpcOptions();

            return options;
        }

        /// <summary>
        /// Passes the NPC Data to an LLM to generate a detailed description.
        /// </summary>
        /// <param name="npcJson"></param>
        /// <returns></returns>
        public async Task<string> DescribeNPC(Townsperson npc)
        {
            string npcJson = SerializeClean(npc);

            // We need to build the Request Object expected by the AI Workload Manager.
            // We invoke the functions by the names they were registered with.
            string functionName = CharGenFunctions.AiFunction_DescribeNPC;

            // We need to provide a dictionary whose KEYS correspond to the "replacement token" strings
            // in the prompt template.  The values are what we want injected into the prompt template
            // in place of those Replacement Tokens.
            Dictionary<string, object?> functionArgs = new Dictionary<string, object?>();
            functionArgs.Add("npcJson", npcJson);

            // Finally, we invoke that function on the AI Workload provider and await the result.
            var functionResult = await _aiWorker.ExecuteFunctionAsync(functionName, functionArgs);
            string description = string.Empty;

            // If it's successful, we should have an answer from the AI.
            // If it's not, the output of THIS method is going to the UI.
            // Let's just return an empty string when the AI Workload fails.
            if (functionResult.WasSuccessful)
            {
                description = functionResult.Payload?.AiResponse??string.Empty;
            }
            else
            {
                //TODO:  Add some logging here.
                description = string.Empty;
            }

            return description;
        }

        /// <summary>
        /// Accepts a string containing the Rolled NPC Attributes, and passes it to 
        /// the LLM Component as a FunctionRequest to get the details generated by
        /// the connected Language Model.
        /// </summary>
        /// <param name="npcJson"></param>
        /// <returns></returns>
        public async Task<OpResult<ResourceResult<GeneratedCharacterProperties>>> GenerateAttributes(string npcJson, string userId, int userAiQuotaId)
        {
			OpResult<ResourceResult<GeneratedCharacterProperties>> apiResult = new OpResult<ResourceResult<GeneratedCharacterProperties>>();
            ResourceResult<GeneratedCharacterProperties> apiPayload = new ResourceResult<GeneratedCharacterProperties>();

            try
            {
				GeneratedCharacterProperties characterAttributes = new GeneratedCharacterProperties();

				// We need to build the Request Object expected by the AI Workload Manager.
				// We invoke the functions by the names they were registered with.

				string functionName = CharGenFunctions.AiFunction_GenerateNPCAttributes;

				// We need to provide a dictionary whose KEYS correspond to the "replacement token" strings
				// in the prompt template.  The values are what we want injected into the prompt template
				// in place of those Replacement Tokens.
				Dictionary<string, object?> functionArgs = new Dictionary<string, object?>();
				functionArgs.Add("npcJson", npcJson);

				// Finally, we invoke that function on the AI Workload provider and await the result.
				var aiManagerResult = await _aiWorker.ExecuteFunctionAsync(functionName, functionArgs);
				string aiJson = string.Empty;

				if (aiManagerResult.WasSuccessful && aiManagerResult.Payload != null)
				{
					AiFunctionResult resultPayload = aiManagerResult.Payload;

					aiJson = resultPayload?.AiResponse ?? string.Empty;
					aiJson = aiJson.StripMarkdown();
					characterAttributes = ParseFromJson(aiJson);

                    apiPayload.Result = characterAttributes;

					//TODO: Consider doing this as a disconnected async operation
					// so we don't have to wait for the DB write to return
					// the AI response to the user.
					var aiTokens = resultPayload!.Consumption;

					TokenUsageEntry usageEntry = new TokenUsageEntry()
					{
						UserId = userId,
						FunctionName = functionName,
						modelId = "gpt-4o",
						InferenceTimeUtc = DateTime.UtcNow,
						PromptTokens = aiTokens?.PromptTokens ?? 0,
						CompletionTokens = aiTokens?.CompletionTokens ?? 0
					};


					var quotaUpdateResult = await _usageManager.ConsumeQuotaAsync(userAiQuotaId, 1, userId);
					await _usageManager.LogTokenConsumption(usageEntry);

                    apiPayload.UpdatedQuotas = quotaUpdateResult.Payload;
                    if(quotaUpdateResult.WasSuccessful == false)
                    {
                        quotaUpdateResult.CopyErrorsTo(ref apiResult);
                    }
				}
				else
				{
                    aiManagerResult.CopyErrorsTo(ref apiResult);

                    if (aiManagerResult.Payload == null)
                    {
                        Guid errorId = Guid.NewGuid();
                        string errorMessage = $"The invocation of {functionName} returned a null result. Other errors may have occurred.";

                        apiResult.AddError(errorId, errorMessage);
                    }
				}
			}
            catch(Exception ex)
            {
                Guid exId = Guid.NewGuid();
                string message = $"Could not create the AI generated details for user {userId}";
                _logger?.LogError(ex, exId.ToString());
                apiResult.AddError(exId, message);
            }
            
            apiResult.Payload = apiPayload;
            return apiResult;
        }

        private GeneratedCharacterProperties ParseFromJson(string json)
        {
            GeneratedCharacterProperties genProps = new GeneratedCharacterProperties();
            // Read the Json into a new Json Document, then interrogate its parts for the 
            // values to assign to the GenProps.
            
            if(string.IsNullOrWhiteSpace(json))
            {
                return genProps;
            }

            using (var doc = JsonDocument.Parse(json))
            {
                if(doc == null)
                {
                    return genProps;
                }

                //TODO:  This is unmaintainable CRAP, and needs to be made unCRAPpy.
                foreach (var element in doc.RootElement.EnumerateObject())
                {
                    switch(element.Name.Trim().ToUpper())
                    {
                        case "NAME":
                            string nameVal = element.Value.GetString() ?? string.Empty;
                            genProps.Name.SetAiValue(nameVal);
                            break;

                        case "PERSONALITY":
                            string personalityVal = element.Value.GetString() ?? string.Empty;
                            genProps.Personality.SetAiValue(personalityVal);
                            break;

                        case "APPEARANCE":
                            string looksVal = element.Value.GetString() ?? string.Empty;
                            genProps.Appearance.SetAiValue(looksVal);
                            break;

                        case "CURRENTCIRCUMSTANCES":
                            string jobVal = element.Value.GetString() ?? string.Empty;
                            genProps.CurrentCircumstances.SetAiValue(jobVal);
                            break;

                        case "BACKGROUND":
                            string histVal = element.Value.GetString() ?? string.Empty;
                            genProps.Background.SetAiValue(histVal);
                            break;

                        default:
                            //Do Nothing.
                            break;
                    }
                }
            }

            return genProps;
        }

        /// <summary>
        /// Randomly generates an NPC from the available options provided by
        /// the configured RuleSet.
        /// </summary>
        /// <returns></returns>
        public Townsperson GenerateNPC()
        {
            var npc = _npcManager.GenerateTownsperson();
            return npc;
        }

        public Townsperson GenerateNPC(TownsfolkUserOptions options)
        {
            Townsperson npc = _npcManager.GenerateTownspersonFromOptions(options);
            return npc;
        }

        public string GetNpcJson(Townsperson npc)
        {
            string npcJson = SerializeClean(npc);
            return npcJson;
        }

        public async Task<OpResult<ResourceResult<Townsperson>>> SaveNpc(Townsperson npc, string userId, int userStorageQuotaId)
        {
            ResourceResult<Townsperson> resourceResult = new ResourceResult<Townsperson>();
            OpResult<ResourceResult<Townsperson>> apiResult = new OpResult<ResourceResult<Townsperson>>(); ;
            
            try
            {
				bool isNewCharacter = (npc.Id == null);

				var managerResult = await _npcManager.SaveTownsperson(npc, userId);
                if(managerResult.WasSuccessful)
                {
                    resourceResult.Result = managerResult.Payload;
					if (isNewCharacter)
					{
						var quotaUpdate = await _usageManager.ConsumeQuotaAsync(userStorageQuotaId, 1, userId);
                        resourceResult.UpdatedQuotas = quotaUpdate.Payload;
					}
				}
                else
                {
                    managerResult.CopyErrorsTo(ref apiResult);
                }
			}
			catch(Exception ex)
            {
                Guid exId = Guid.NewGuid();
                string message = $"There was a problem saving the npc for user {userId}";
                _logger?.LogError(ex, exId.ToString());
                apiResult.AddError(exId, message);
            }

            apiResult.Payload = resourceResult;
            return apiResult;
        }

        public async Task<OpResult<IEnumerable<FilteredTownsperson>>> FilterTownsfolk(TownspersonFilter filter)
        {
            var apiResult = await _npcManager.FilterTownspeople(filter);
            return apiResult;
        }

        public async Task<OpResult<Townsperson?>> LoadTownsperson(int townspersonId, string userId)
        {
            var apiResult = await _npcManager.LoadTownsperson(townspersonId, userId);
            return apiResult;
        }

        //TODO: Maybe refactor this out to a different WorkloadManager if / when it makes sense.
        public async Task<OpResult<QuotaContainer>> LoadUserQuotas(string userId)
        {
            OpResult<QuotaContainer> apiResult = new OpResult<QuotaContainer>();
            QuotaContainer? apiPayload = null;

            try
            {
                var mgrResult = await _usageManager.LoadUserQuotaAsync(userId);
                if(mgrResult.WasSuccessful)
                {
                    apiPayload = mgrResult.Payload;
                }
                else
                {
                    mgrResult.CopyErrorsTo(ref apiResult);
                }
            }
            catch(Exception ex)
            {
                Guid exId = Guid.NewGuid();
                string message = $"An error occurred while loading the quotas for userId {userId}.";

                _logger?.LogError(ex, exId.ToString());
                apiResult.AddError(exId, message);
            }

            apiResult.Payload = apiPayload;
            return apiResult;
        }

        /// <summary>
        /// Serializes an object to JSON
        /// Uses the JsonFunctions to strip all properties
        /// from a complex object that have not been populated.
        /// </summary>
        /// <typeparam name="T">The Type of object</typeparam>
        /// <param name="instance">An Instance of T</param>
        /// <returns></returns>
        private string SerializeClean<T>(T instance) where T : class
        {
            string json = JsonUtilities.GetCleanJson(instance);

            return json;
        }

    }
}
